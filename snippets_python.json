{
	"GCD": {
		"prefix": "gcd",
		"body":[
			"from math import gcd   # gcd(6, 4) -> 2",
			"from functools import reduce",
			"",
			"def gcd_list(numbers):",
			"\treturn reduce(gcd, numbers)"
		],
		"description": "最大公約数を求める"
	},

	"LCM": {
		"prefix": "lcm",
		"body": [
			"from math import gcd",
			"",
			"def lcm(m, n):",
			"\treturn (m * n) // gcd(m, n)",
			"",
			"def lcm_list(a):",
			"\tx = a[0]",
			"\tfor i in range(1, len(a)):",
			"\t\tx = (x * a[i]) // gcd(x, a[i])",
			"\treturn x"
		],
		"description": "最小公倍数を求める"
	},

	"IS_PRIME": {
		"prefix": "is_prime",
		"body": [
			"def is_prime(n):",
			"\tif n == 1:",
			"\t\treturn False",
			"\tfor i in range(2,int(n**0.5)+1):",
			"\t\tif n % i == 0:",
			"\t\t\treturn False",
			"\treturn True"
		],
		"description": "素数判定"
	},

	"DIGSUM": {
		"prefix": "digsum",
		"body": [
			"def digsum(n):",
			"\ttotal = 0",
			"\twhile n > 0:",
			"\t\ttotal += n%10",
			"\t\tn /= 10",
			"\t\tn = int(n)",
			"\treturn total"
		],
		"description": "桁和"
	},

	"LIST_INPUT": {
		"prefix": "list(map(int, input().split()))",
		"body": [
			"list(map(int, input().split()))"
		],
		"description": "listの標準入力"
	},

	"NUMER_INPUT": {
		"prefix": "map(int, input().split())",
		"body": [
			"map(int, input().split())"
		],
		"description": "numberの標準入力"
	},

	"STRING_INPUT": {
		"prefix": "list(input().split())",
		"body": [
			"list(input().split())"
		],
		"description": "stringをリストで標準入力"
	},

	"FACTORIZATION": {
		"prefix": "factorization",
		"body": [
			"def factorization(n):",
			"\tarr, temp = [], n",
			"\tfor i in range(2, int(-(-n**0.5//1))+1):",
			"\t\tif temp%i==0:",
			"\t\t\tcnt=0",
			"\t\t\twhile temp%i==0:",
			"\t\t\t\tcnt+=1",
			"\t\t\t\ttemp //= i",
			"\t\t\tarr.append([i, cnt])",
			"\tif temp!=1:",
			"\t\tarr.append([temp, 1])",
			"\tif arr==[]:",
			"\t\tarr.append([n, 1])",
			"\treturn arr"
		],
		"description": "素因数分解"
	},

	"KIRIAGE_KIRISUTE": {
		"prefix": "kiriage_kirisute",
		"body": [
			"from math import ceil, floor",
			"#ceil()  # 切り上げ。常にup",
			"#floor()  # 切り捨て。常にdown",
			"#int()  # 常に0に近く（正負で挙動違う）",
			"#round(f),  round(f, 1)  # 四捨五入（第二引数で小数点桁数を指定）"  
		],
		"description": "切り上げや切り捨て"
	},

	"KAIBUN": {
		"prefix": "kaibun",
		"body": [
			"def kaibun(s):",
			"\tn_iter = len(s)//2",
			"\tans = True",
			"\tfor i in range(n_iter):",
			"\t\tif s[i] != s[-1-i]:",
			"\t\t\tans = False",
			"\t\t\tbreak",
			"\treturn ans"
		],
		"description": "文字の回文判定"
	},

	"ITERTOOLS": {
		"prefix": "itertools",
		"body": [
			"from itertools import (",
			"\taccumulate,  # 累積和のイテレータ",
			"\tgroupby,  # 値をkey,同じ値の集まりをgroup",
			"\tpermutations,  # 順列",
			"\tcombinations,  # 組み合わせ",
			"\tproduct,  # 重複あり順列（直積, 深いネストにも使える）",
			"\tcombinations_with_replacement,  # 重複あり組み合わせ",
			")"
		],
		"description": "itertoolsの各モジュール"
	},

	"COUNTER": {
		"prefix": "counter",
		"body": [
			"from collections import Counter",
			"#l = ['a', 'a', 'a', 'a', 'b', 'c', 'c']",
			"#c = Counter(l)",
			"#print(c)   # Counter({'a': 4, 'c': 2, 'b': 1})"
		],
		"description": "リストの各要素をカウントする"
	},

	"DEQUE": {
		"prefix": "deque",
		"body": [
			"from collections import deque",
			"#S = deque(['x', 'y'])",
			"#print(S)   ->   deque(['x', 'y'])",
			"#popleft  ->  キュー",
			"#pop  ->  スタック"
		],
		"description": "キュー"
	},

	"FACTORIAL": {
		"prefix": "factorial",
		"body": [
			"from math import factorial    #階乗計算",
			"#print(math.factorial(5))   ->   120"
		],
		"description": "階乗計算"
	},

	"BISECT": {
		"prefix": "bisect",
		"body": [
			"from bisect import bisect_left, bisect_right  # return index",
			"",
			"def search(t, i):",
			"\t'''存在するかどうかを返す",
			"\tt: list,   i: value'''",
			"\tix = bisect_right(t, i)",
			"\tif t[ix-1] != i:",
			"\t\treturn False",
			"\treturn True"
		],
		"description": "二分探索"
	},

	"COMBINATIONS": {
		"prefix": "combinations",
		"body": [
			"def cmb(n, r, MOD=1):",
			"\t'''",
			"\tnCrを求める",
			"\tMODはデフォルトで1",
			"\t'''",
			"\tnumerator = 1",
			"\tdenominator = 1",
			"\tfor l in range(r):",
			"\t\tnumerator *= (n - l)",
			"\t\tnumerator %= MOD",
			"\t\tdenominator *= (l + 1)",
			"\t\tdenominator %= MOD",
			"\tinv = pow(denominator ,MOD - 2 ,MOD)",
			"\treturn (numerator * inv) % MOD"
		],
		"description": "(nCr) 組み合わせの数を返す"
	},

	"BFS": {
		"prefix": "bfs",
		"body": [
			"def bfs(sy, sx, gy, gx, c, visited):",
			"\t'''",
			"\tc: 与えられた経路",
			"\tvisited: 見つかった距離、及び未探索フラグ",
			"\t'''",
			"\tvisited[sy][sx] = 0",
			"\tQ = deque([])",
			"\twhile Q:",
			"\t\ty,x = Q.popleft()",
			"\t\tif [y, x] == [gy, gx]:",
			"\t\t\treturn visited[y][x]",
			"\t\tfor i, j in [(0, 1), (1, 0), (-1, 0), (0, -1)]:",
			"\t\t\tif c[y+i][x+j] == '.' and visited[y+i][x+j] == -1:",
			"\t\t\t\t# 探索可能かつ未探索の場合",
			"\t\t\t\tvisited[y+i][x+j] = visited[y][x]+1",
			"\t\t\t\tQ.append([y+i,x+j])"
		],
		"description": "幅優先探索"
	},

	"HEAPQ": {
		"prefix": "heapq",
		"body": [
			"from heapq import (",
			"\theapify,  # 優先度付きキューの生成",
			"\theappop,  # キューから値を取り出す",
			"\theappush,   # キューに値を格納",
			"\theappushpop,   # push -> popの順",
			"\theapreplace,   # pop -> pushの順",
			"\t)"
		],
		"description": "優先度付きキュー"
	},

	"BIT_ALL_SEARCH": {
		"prefix": "bit",
		"body": [
			"for i in range(1<<N):",
			"\tcond = [0]*N",
			"\tfor j in range(N):",
			"\t\tif 1&(i>>j):  # 右シフトして論理積（bit全探索）",
			"\t\t\tcond[j] = 1"
		],
		"description": "bit全探索"
	},

	"DIVISORS": {
		"prefix": "divisors",
		"body": [
			"def divisors(n):",
			"\t'''約数列挙'''",
			"\tdiv = []",
			"\tfor i in range(1, int(n**0.5)+1):",
			"\t\tif n % i == 0:",
			"\t\t\tdiv.append(i)",
			"\t\t\tif i != n // i:",
			"\t\t\t\tdiv.append(n//i)",
			"",
			"\t# divisors.sort()  # ソートの必要あれば",
			"\treturn div"
		],
		"description": "約数列挙"
	},

	"SAIKI": {
		"prefix": "saiki",
		"body": [
			"import sys",
			"sys.setrecursionlimit(10**9)"
		],
		"description": "再帰上限のup"
	},

	"Multi Sort": {
		"prefix": "multi_sort",
		"body": [
		  "A = [[1, 2], [3, 1], [2, 5]]",
		  "B = sorted(A, key=lambda x: x[0]) # 0番目の要素でソート",
		  "C = sorted(A, key=lambda x: x[1]) # 1番目の要素でソート"
		],
		"description": "多次元配列のソート"
	},

	"binrary_tree": {
		"prefix": "binrary_tree",
		"body": [
		  "import random #入力整数列Aの生成に使用",
		  "",
		  "class Node:",
		  "    def __init__(self, data): #コンストラクタ",
		  "        self.data = data #ノードがもつ数値",
		  "        self.left = None #左エッジ",
		  "        self.right = None #右エッジ",
		  "",
		  "",
		  "class BST:",
		  "    def __init__(self, number_list): #コンストラクタ",
		  "        self.root = None #ルートノード初期化",
		  "        for node in number_list: #数値を持つ配列から二分木を生成",
		  "            self.insert(node) #挿入メソッドを使ってノードを挿入する",
		  "    #挿入",
		  "    def insert(self, data):",
		  "        n = self.root",
		  "        if n == None:",
		  "            self.root = Node(data)",
		  "            return",
		  "        else:",
		  "            while True:",
		  "                entry = n.data",
		  "                if data < entry:",
		  "                    if n.left is None:",
		  "                        n.left = Node(data)",
		  "                        return",
		  "                    n = n.left",
		  "                elif data > entry:",
		  "                    if n.right is None:",
		  "                        n.right = Node(data)",
		  "                        return",
		  "                    n = n.right",
		  "                else:",
		  "                    n.data = data",
		  "                    return",
		  "    #検索機能(インターフェース)",
		  "    def search(self, search):",
		  "        searcher = self._search_bool(search)",
		  "        if searcher is None:",
		  "            print(\"Search target is not found.\")",
		  "        elif searcher == True:",
		  "            print(str(search) + \" is found!\")",
		  "        elif searcher == False:",
		  "            print(str(search) + \" is not found.\")",
		  "",
		  "    #検索機能本体(出力:boolean),深さ優先探索",
		  "    #nodeのvisitedはpopで代用",
		  "    def _search_bool(self, search):",
		  "        n = self.root",
		  "        if n is None:",
		  "            return None",
		  "        else:",
		  "            lst = []",
		  "            lst.append(n)",
		  "            while len(lst) > 0:",
		  "                node = lst.pop()",
		  "                if node.data == search:",
		  "                    return True",
		  "                if node.right is not None:",
		  "                    lst.append(node.right)",
		  "                if node.left is not None:",
		  "                    lst.append(node.left)",
		  "            return False",
		  "",
		  "    def inorder(self,node): #中順探索 l->r->p^n",
		  "        if node is not None:",
		  "            self.inorder(node.left)",
		  "            print(node.data)",
		  "            self.inorder(node.right)"
		],
		"description": "二分木探索"
	  },

	"UnionFindTree": {
		"prefix": "unionfindtree",
		"body": [
		  "class UnionFind:",
		  "    def __init__(self, n):",
		  "        self.par = [i for i in range(n)] #親",
		  "        self.rank = [0 for _ in range(n)] #根の深さ",
		  "",
		  "    #xの属する木の根を求める",
		  "    def find(self, x):",
		  "        if self.par[x] == x:",
		  "            return x",
		  "        else:",
		  "            self.par[x] = self.find(self.par[x])",
		  "            return self.par[x]",
		  "",
		  "    #xとyの属する集合のマージ",
		  "    def unite(self, x, y):",
		  "        x = self.find(x)",
		  "        y = self.find(y)",
		  "        if x == y:",
		  "            return",
		  "        if self.rank[x] < self.rank[y]:",
		  "            self.par[x] = y",
		  "        else:",
		  "            self.par[y] = x",
		  "            if self.rank[x] == self.rank[y]:",
		  "                self.rank[x] += 1",
		  "",
		  "    #xとyが同じ集合に属するかを判定",
		  "    def same(self, x, y):",
		  "        return self.find(x) == self.find(y)"
		],
		"description": "UnionFind木"
	  },

	"Kruskal": {
		"prefix": "kuraskal",
		"body": [
		  "#union-find木",
		  "#クラスカル法にはUnion-find木が必要",
		  "class UnionFind:",
		  "    def __init__(self, n):",
		  "        self.par = [i for i in range(n)] #親",
		  "        self.rank = [0 for _ in range(n)] #根の深さ",
		  "",
		  "    #xの属する木の根を求める",
		  "    def find(self, x):",
		  "        if self.par[x] == x:",
		  "            return x",
		  "        else:",
		  "            self.par[x] = self.find(self.par[x])",
		  "            return self.par[x]",
		  "",
		  "    #xとyの属する集合のマージ",
		  "    def unite(self, x, y):",
		  "        x = self.find(x)",
		  "        y = self.find(y)",
		  "        if x == y:",
		  "            return",
		  "        if self.rank[x] < self.rank[y]:",
		  "            self.par[x] = y",
		  "        else:",
		  "            self.par[y] = x",
		  "            if self.rank[x] == self.rank[y]:",
		  "                self.rank[x] += 1",
		  "",
		  "    #xとyが同じ集合に属するかを判定",
		  "    def same(self, x, y):",
		  "        return self.find(x) == self.find(y)",
		  "",
		  "",
		  "#クラスカル法",
		  "# V: 頂点集合(リスト) E: 辺集合[始点, 終点, 重み](リスト)",
		  "class kruskal():",
		  "    def __init__(self, V, E):",
		  "        self.V = V",
		  "        self.E = E",
		  "        self.E.sort(key=lambda x: x[2]) #辺の重みでソート",
		  "",
		  "    def weight(self): #最小全域木の重み和を求める",
		  "        UF = UnionFind(len(V)) #頂点数でUnion Find Treeを初期化",
		  "        res = 0",
		  "        for i in range(len(self.E)):",
		  "            e = self.E[i]",
		  "",
		  "            if (UF.same(e[0], e[1])) == False:",
		  "                UF.unite(e[0], e[1])",
		  "                res += e[2]",
		  "",
		  "        return res",
		  "",
		  "    def edge(self):",
		  "        UF = UnionFind(len(self.V)) #頂点数でUnion Find Treeを初期化",
		  "        res_E = []",
		  "        for i in range(len(self.E)):",
		  "            e = self.E[i]",
		  "",
		  "            if (UF.same(e[0], e[1])) == False:",
		  "                UF.unite(e[0], e[1])",
		  "                res_E.append(e)",
		  "",
		  "        return res_E",
		  "",
		  "    def node(self):",
		  "        UF = UnionFind(len(V)) #頂点数でUnion Find Treeを初期化",
		  "        res_V = []",
		  "        for i in range(len(E)):",
		  "            e = E[i]",
		  "",
		  "            if (UF.same(e[0], e[1])) == False:",
		  "                UF.unite(e[0], e[1])",
		  "                res_V.append(e[0])",
		  "                res_V.append(e[1])",
		  "",
		  "        return list(set(res_V))"
		],
		"description": "クラスカル法"
	},

	"WarshallFloyd": {
		"prefix": "warshall_floyd",
		"body": [
		  "#d[i][j]は2頂点間i, j間の移動コストを格納, Vは頂点数",
		  "def warshall_floyd(d, V): ",
		  "    for k in range(V):",
		  "        for i in range(V):",
		  "            for j in range(V):",
		  "                d[i][j] = min(d[i][j], d[i][k] + d[k][j])",
		  "",
		  "    return d #d[i][j]に頂点i, j間の最短距離を格納"
		],
		"description": "ワーシャルフロイド法"
	  },

	  "": {
		"prefix": "point_line",
		"body": [
		  "def get_line_formula(x1, y1, x2, y2):",
		  "    \"\"\"",
		  "    (x1, y1)と(x2, y2)の2点を通過する直線の式",
		  "    a*x + b*y +c = 0",
		  "    return a, b, c",
		  "    \"\"\"",
		  "    # x軸と並行",
		  "    if y1==y2:",
		  "        return 0, 1, -y1",
		  "    # y軸と並行",
		  "    elif x1==x2:",
		  "        return 1, 0, -x1",
		  "    else:",
		  "        a = (-(y1 - y2)) / (x1 - x2)",
		  "        b = 1",
		  "        c = - (a * x1) - y1",
		  "        return a, b, c",
		  "",
		  "",
		  "def get_point_line_distance(x, y, a, b, c):",
		  "    \"\"\"",
		  "    直線: a*x + b*y + c = 0",
		  "    点: x, y",
		  "    の距離を返す",
		  "    \"\"\"",
		  "    return abs(a*x + b*y + c) / ((a**2 + b**2) ** 0.5)"
		],
		"description": "点と直線関係"
	  }
}